// title: 第k个排列

// 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

// 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

// "123"
// "132"
// "213"
// "231"
// "312"
// "321"
// 给定 n 和 k，返回第 k 个排列。

// 说明：

// 给定 n 的范围是 [1, 9]。
// 给定 k 的范围是[1,  n!]。
// 示例 1:

// 输入: n = 3, k = 3
// 输出: "213"
// 示例 2:

// 输入: n = 4, k = 9
// 输出: "2314"

// 思路，假设n=5,k=35,
// n为5的全排列就是首位为1-5的如下排列的所有
// 1_,,,2,,,3,,,4,,,5,,,每个各有24个排列，组成12345的全排列
// 由于k=35<48,也就是说第35个肯定在首位为2的全排列里边,所以第一个取2。
// 接下来就是考虑剩下1345这四个数的全排列里边取第k=35-24=11个，
// 1,,3,,4,,5,,每个各有6个排列，组成1345的全排列，
// 由于k=11<12,也就是说第11个肯定在首位为3的全排列里边，所以第二个数取3
// 接下来就是考虑剩下145这三个数的全排列里边取第k=11-6=5个，
// 1,4,5,_每个各有2个排列，组成145的全排列
// 由于k=5<6,也就是说第5个肯定在首位为5的全排列里边，所以第三个数取5
// 接下来就是考虑剩下14这两个数的排列里边取第k=5-4=1个
// 1_4_每个各有1个排列，组成14的排列，
// 由于k=1,所以第四个数取1
// 最后加上剩下的最后一个4，结果就是23514

/**
 * @param {number} n
 * @param {number} k
 * @return {string}
 */
var getPermutation = function (n, k) {
  let result = ''
  let nums = [] // 存储所有数字
  for (let i = 1; i <= n; i++) {
    nums.push(i)
  }
  while (k) {
    if (n > 1) {
      let temp = tempFn(--n) // 计算n - 1阶乘, 同时n减一
      let num = Math.ceil(k / temp) // 计算出选择第几位
      k = k - (num - 1) * temp // 如果num
      result += nums[num - 1]
      nums.splice(num - 1, 1)
    } else {
      result += nums[0]
      break
    }
  }
  return result
};

function tempFn(n) {
  if (n <= 1) return 1
  return n * tempFn(n - 1)
}
// case1 输入：n = 3, k = 3 预期："213"
console.log(getPermutation(3, 6))

// case2 输入：n = 4, k = 9 预期：'2314'
console.log(getPermutation(4, 9))