/*
 *
 * [77] 组合
 *
 * https://leetcode-cn.com/problems/combinations/description/
 *
 * algorithms
 * Medium (74.46%)
 *
 * 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
 *
 * 示例:
 *
 * 输入: n = 4, k = 2
 * 输出:
 * [
 * ⁠ [2,4],
 * ⁠ [3,4],
 * ⁠ [2,3],
 * ⁠ [1,2],
 * ⁠ [1,3],
 * ⁠ [1,4],
 * ]
 *
 */

//  pre是已选择元素列表
// 其实如果 pre 已经选择到 [1,4,5] 或者 [2,4,5] 或者 [3,4,5] ，后序的代码就没有必要执行，
// 继续走也不能发现新的满足题意的组合。干了类似于下面事情，其实有很多步骤是多余的：
// 选择了 [1,4,5] 以后， 5 弹出 [1,4,5] 成为 [1,4] , 4 弹出 [1,4] 成为 4 ，
// 然后 5 进来，成为 [1,5]，在进来发现 for 循环都进不了（因为没有可选的元素），然后 5 又弹出，接着 1 弹出。

// 发现多余操作：那么我们如何发现多余的步骤呢，其实也是有规律可寻的，就在 for 循环中：

// for (int i = start; i <= n; i++) {
//     pre.add(i);
//     generateCombinations(n, k, i + 1, pre);
//     pre.remove(pre.size() - 1);
// }
// 这个函数干的事情，是从 [i, n] 这个区间里（注意，左右都是闭区间），找到 k - pre.zize() 个元素。
// i <= n 不是每一次都要走完的， i 有一个上限。

// 寻找规律：我们再看图，可以发现一些边界情况，帮助我们发现规律:

// 当选定了一个元素，即 pre.size() == 1 的时候，接下来要选择 2 个元素， i 最大的值是 4 ，因为从 5 开始选择，就无解了；
// 当选定了两个元素，即 pre.size() == 2 的时候，接下来要选择 1 个元素， i 最大的值是 5 ，因为从 6 开始选择，就无解了。

// 再如：如果 n = 6 ，k = 4，
// pre.size() == 1 的时候，接下来要选择 3 个元素， i 最大的值是 4，最后一个被选的是 [4,5,6]；
// pre.size() == 2 的时候，接下来要选择 2 个元素， i 最大的值是 5，最后一个被选的是 [5,6]；
// pre.size() == 3 的时候，接下来要选择 1 个元素， i 最大的值是 6，最后一个被选的是 [6]；

// 再如：如果 n = 15 ，k = 4，
// pre.size() == 1 的时候，接下来要选择 3 个元素，i 最大的值是 13，最后一个被选的是 [13,14,15]；
// pre.size() == 2 的时候，接下来要选择 2 个元素， i 最大的值是 14，最后一个被选的是 [14,15]；
// pre.size() == 3 的时候，接下来要选择 1 个元素， i 最大的值是 15，最后一个被选的是 [15]；

// 多写几遍（发现 max(i) 是我们倒着写出来），我么就可以发现 max(i) 与 接下来要选择的元素貌似有一点关系，很容易知道：
// max(i) + 接下来要选择的元素个数 - 1 = n，其中， 接下来要选择的元素个数 = k - pre.size()，整理得到：

// max(i) = n - (k - pre.size()) + 1
// 所以，我们的剪枝过程就是：把 i <= n 改成 i <= n - (k - pre.size()) + 1

/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
  if (n < k) return []
  let result = []
  recur(n, k, [], result, 0)
  return result
}
function recur(n, k, temp, result, start) {
  if (temp.length === k) {
    result.push(temp)
    return
  }
  for (let i = start; i < n - (k - temp.length) + 1; i++) {
    let variable = [...temp, i + 1]
    recur(n, k, variable, result, i + 1)
  }
}

// case1 输入：n = 4, k = 2 预期：[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 3 ], [ 2, 4 ], [ 3, 4 ] ]
console.log(combine(4, 2))
